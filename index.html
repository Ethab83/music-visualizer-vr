<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webaudio - visualizer</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">

	</head>
	<body>
		<div id="overlay">
			<button id="startButton">Play</button>
		</div>
		<div id="container"></div>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener noreferrer">three.js</a> webaudio - visualizer<br/>
			music by <a href="http://www.newgrounds.com/audio/listen/376737" target="_blank" rel="noopener">Toshiki Kadomatsu
            </a>
		</div>

		<script type="importmap">
			{
				"imports": {
                    "three": "https://unpkg.com/three@latest/build/three.module.js",
                    "three/addons/": "https://unpkg.com/three@latest/examples/jsm/",
                    "dat.gui": "https://unpkg.com/dat.gui@latest/build/dat.gui.module.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
            import { OrbitControls } from 'three/addons/controls/OrbitControls.js';      
            import { Water } from 'three/addons/objects/Water.js';
            import * as dat from 'dat.gui';

            let scene, camera, renderer, analyser, controls;

            // * * * SETTINGS and HELPER for DAT.GUI * * * 
            window['SCENE'] = {
                Modulators: []
            }

            // Define the sources and destinations
            // Define the sources and destinations
            const sources = {
                'Spectrum Analyzer': () => analyser.data,
                'Bass': () => getAmplitude(0, analyser.data.length / 4, analyser.data),
                'Treble': () => getAmplitude(analyser.data.length / 4, analyser.data.length / 2, analyser.data),
                'Mid': () => getAmplitude(analyser.data.length / 2, analyser.data.length * 3 / 4, analyser.data),
                'High': () => getAmplitude(analyser.data.length * 3 / 4, analyser.data.length, analyser.data),
                'Volume': () => getAmplitude(0, analyser.data.length, analyser.data),
                'Noise Function': () => { /* TODO */ }
            };

            const destinations = {
                'Water': null
            };

            const destinationParams = {
                'Object': morphObject,
                'Color': morphColor,
                'Size': morphSize,
                'Position': morphPosition
            };

            let numModulators = 0;

            // Define an object to hold the data for dat.GUI
            const modData = {
                source: Object.keys(sources)[0],
                destination: Object.keys(destinations)[0],
                destinationParam: Object.keys(destinationParams)[0],
                x: 50,
                y: 50,
                addModulator: function() {
                        
                    const newFolder = gui.addFolder('Modulator ' + ++numModulators);

                    // Add a dropdown for the sources and destinations to the GUI
                    newFolder.add(modData, 'source', Object.keys(sources));
                    newFolder.add(modData, 'destination', Object.keys(destinations));
                    newFolder.add(modData, 'destinationParam', Object.keys(destinationParams));
                    newFolder.add(modData, 'x').min(1).max(100.0);
                    newFolder.add(modData, 'y').min(1).max(100.0);

                    // Open the folder
                    newFolder.open();
                    
                    // Store the Modulator settings
                    SCENE.Modulators.push({ this: this });
                    
                    // Add the x and y parameters to the destinations object
                    destinations['Modulator ' + numModulators + '->x'] = modData.x;
                    destinations['Modulator ' + numModulators + '->y'] = modData.y;
                }
            };

            // Create a new instance of dat.GUI
            const gui = new dat.GUI();

            // Add a button to the GUI
            gui.add(modData, 'addModulator').name('Add Modulator');

            let originalPositions = [];

			const startButton = document.getElementById( 'startButton' );
			startButton.addEventListener( 'click', init );

            var bufferLength = 128;

			function init() {

				const fftSize = bufferLength;

				const overlay = document.getElementById( 'overlay' );
				overlay.remove();

				const container = document.getElementById( 'container' );

                scene = new THREE.Scene();
                var group = new THREE.Group();
                camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0,0,100);
                camera.lookAt(scene.position);
                scene.add(camera);
                
                renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                

				const listener = new THREE.AudioListener();

				const audio = new THREE.Audio( listener );
				const file = './sounds/sea-line.mp3';

				if ( /(iPad|iPhone|iPod)/g.test( navigator.userAgent ) ) {

					const loader = new THREE.AudioLoader();
					loader.load( file, function ( buffer ) {

						audio.setBuffer( buffer );
						audio.play();

					} );

				} else {

					const mediaElement = new Audio( file );
					mediaElement.play();

					audio.setMediaElementSource( mediaElement );

				}

				analyser = new THREE.AudioAnalyser( audio, fftSize );

				const format = ( renderer.capabilities.isWebGL2 ) ? THREE.RedFormat : THREE.LuminanceFormat;

                var waterGeometry = new THREE.PlaneGeometry(10000, 10000, 20, 20);

                // Adjust the material properties
                var waterMaterial = new THREE.MeshStandardMaterial({
                    color: 0x6904ce,
                    side: THREE.DoubleSide,
                    metalness: 0.02,
                });
                
                destinations['Water'] = new Water(
                    waterGeometry,
                    {
                        textureWidth: 512,
                        textureHeight: 512,
                        waterNormals: new THREE.TextureLoader().load('textures/waternormals.jpg', function (texture) {
                            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                        }),
                        alpha: 1.0,
                        sunDirection: new THREE.Vector3(),
                        sunColor: 0xffffff,
                        waterColor: 0x001e0f,
                        distortionScale: 3.7,
                        fog: scene.fog !== undefined
                    }
                );
                destinations['Water'].rotation.x = -0.5 * Math.PI;
                destinations['Water'].position.set(0, -100, 0);

                group.add(destinations['Water']);
                
                var ambientLight = new THREE.AmbientLight(0xaaaaaa);
                scene.add(ambientLight);
                

                var light = new THREE.DirectionalLight( 0xffffff, 5.0 );
                light.position.set( 10, 10, 50 );
                scene.add( light );

                scene.add(group);

                scene.fog = new THREE.FogExp2(0x000000, 0.001);
                renderer.setClearColor(scene.fog.color);
                
                container.appendChild(renderer.domElement);
                    
                // Store the original positions of the vertices
                const positions = destinations['Water'].geometry.attributes.position;
                for (let i = 0; i < positions.count; i++) {
                    originalPositions.push(new THREE.Vector3(
                        positions.array[i * 3 + 0],
                        positions.array[i * 3 + 1],
                        positions.array[i * 3 + 2]
                    ));
                }
                
                controls = new OrbitControls( camera, renderer.domElement );
				window.addEventListener( 'resize', onWindowResize );

                modData.addModulator();


				animate();

			}



			function onWindowResize() {
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {

				requestAnimationFrame( animate );

                analyser.getFrequencyData();
                controls.update();    
                
                // Apply all Modulators
                for (let Modulator of SCENE.Modulators) {
                    destinationParams[Modulator.this.destinationParam](destinations[Modulator.this.destination], sources[Modulator.this.source](), Modulator.this.x, Modulator.this.y);
                }
                
                renderer.render( scene, camera );
			}

            function morphObject(object, modData, x, y) {
                console.log(object)
                switch(object.type) {
                    case 'Mesh':
                        switch(object.geometry.type) {
                            case 'PlaneGeometry':
                                morphPlane(modData, x, y);
                                break;
                            default:
                                morphMesh(object, modData, x, y);
                                break;
                        }
                        break;
                    case 'Light':
                        morphLight(object, modData, x, y);
                        break;
                }
            }

            function morphColor(object, modData, x, y) {
                const color = object.material.color;
                console.log(object)
                const data = modData[0] / 256.0;
                const displacement = data * x;

                // Update the vertex position based on the original position
                color = new THREE.Color(displacement, displacement, displacement);
            }

            function morphSize(object, modData, x, y) {
                const data = modData[0] / 256.0;
                const displacement = data * modScale;

                // Update the vertex position based on the original position
                object.scale.x = displacement;
                object.scale.y = displacement;
                object.scale.z = displacement;
            }

            function morphPosition(object, modData, x, y) {
                const data = modData[0] / 256.0;
                const displacement = data * modScale;

                // Update the vertex position based on the original position
                object.position.z = displacement;
            }

            function morphPlane(modData, width, height) {
                // if modData is one element
                if (modData.length == null) {
                    modData = [modData];
                    console.log('TODO: implement')
                }
                // Modulate the vertices based on the audio data
                const positions = destinations['Water'].geometry.attributes.position;
                for (let i = 0; i < positions.count; i++) {
                    const originalPosition = originalPositions[i];
                    const distance = Math.sqrt(
                        Math.pow(originalPosition.x, 2) +
                        Math.pow(originalPosition.y, 2) +
                        Math.pow(originalPosition.z, 2)
                    );
                    const data = modData[Math.floor(distance / (width / 10)) % analyser.data.length] / 256.0;
                    const displacement = data * height;

                    // Update the vertex position based on the original position
                    positions.array[i * 3 + 0] = originalPosition.x;
                    positions.array[i * 3 + 1] = originalPosition.y;
                    positions.array[i * 3 + 2] = originalPosition.z + displacement;
                }

                // Need to set this flag to true so the changes are picked up by the renderer
                destinations['Water'].geometry.attributes.position.needsUpdate = true;
            }

            function morphLight(object, modData, x, y) {
                const data = modData[0] / 256.0;
                const displacement = data * modScale;

                // Update the vertex position based on the original position
                object.intensity = displacement;
            }

            // not actual frequency, just proportional to it
            function getAmplitude(freqLow, freqHigh, data) {
                let total = 0;
                for (let i = freqLow; i <= freqHigh; i++) {
                    total += data[i];
                }
                return total / (freqHigh - freqLow + 1);
            }

		</script>

	</body>
</html>