<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webaudio - visualizer</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
    
</head>
<body>
    <div id="overlay">
        <button id="startButton">Play</button>
    </div>
    <div id="container"></div>
    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener noreferrer">three.js</a> music - visualizer - vr<br/>
        music by <a href="https://yewtu.be/watch?v=J3xcLmS31FE" target="_blank" rel="noopener">Toshiki Kadomatsu
        </a>
    </div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@latest/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@latest/examples/jsm/",
                "three/examples/": "https://unpkg.com/three@latest/examples/jsm/",
                "dat.gui": "https://unpkg.com/dat.gui@latest/build/dat.gui.module.js"
            }
        }
    </script>
    
    <script type="module">
        
        import * as dat from 'dat.gui';
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';      
        import { Water } from 'three/addons/objects/Water.js';
        import { XRControllerModelFactory } from 'three/examples/webxr/XRControllerModelFactory.js';
        import { VRButton } from 'three/examples/webxr/VRButton.js';
        
        
        
        // * * * DAT.GUI * * *
        
        window['SCENE'] = {
            Modulators: [],
            Destinations: {
                'Water': null,
                'Light1': null,
                'Light2': null,
            },
            Sources: {
                'Spectrum Analyzer': () => analyser.data,
                'Bass': () => getAmplitude(0, analyser.data.length / 4, analyser.data),
                'Treble': () => getAmplitude(analyser.data.length / 4, analyser.data.length / 2, analyser.data),
                'Mid': () => getAmplitude(analyser.data.length / 2, analyser.data.length * 3 / 4, analyser.data),
                'High': () => getAmplitude(analyser.data.length * 3 / 4, analyser.data.length, analyser.data),
                'Volume': () => getAmplitude(0, analyser.data.length, analyser.data),
            },
            DestinationParams: {
                'Position': morphPosition,
                // 'Color': morphColor,
                // 'Size': morphSize,
            },
            AddModulator: addModulator
        }
        
        // Define an object to hold the data for dat.GUI
        class modData {
            constructor(source, destination, destinationParam, x, y) {
                SCENE.Modulators.push(this);
                
                this.source = Object.keys(SCENE.Sources)[source];
                this.destination = Object.keys(SCENE.Destinations)[destination];
                this.destinationParam = Object.keys(SCENE.DestinationParams)[destinationParam];
                this.x = x;
                this.y = y;
            }
        }
        
        function addModulator(source=0, destination=0, destinationParam=0, x=50, y=50) {
            let modulator = new modData(source, destination, destinationParam, x, y);
            
            let numModulators = SCENE.Modulators.length;
            
            const newFolder = gui.addFolder('Modulator ' + numModulators);
            
            // Add a dropdown for the sources and destinations to the GUI
            newFolder.add(modulator, 'source', Object.keys(SCENE.Sources));
            newFolder.add(modulator, 'destination', Object.keys(SCENE.Destinations));
            newFolder.add(modulator, 'destinationParam', Object.keys(SCENE.DestinationParams));
            newFolder.add(modulator, 'x').min(1).max(100.0);
            newFolder.add(modulator, 'y').min(1).max(100.0);
            
            // Add the x and y parameters to the destinations object
            SCENE.Destinations['Modulator ' + numModulators + '→x'] = modData.x;
            SCENE.Destinations['Modulator ' + numModulators + '→y'] = modData.y;
        }
        
        // Create a new instance of dat.GUI
        const gui = new dat.GUI();
        
        // Add a button to add a modulator
        gui.add(SCENE, 'AddModulator');
        
        
        
        // * * * GLOBALS * * *
        
        var bufferLength = 128;
        
        let scene, camera, renderer, analyser, controls;
        
        
        
        // * * * MAIN * * *
        
        function init() {
            
            const overlay = document.getElementById( 'overlay' );
            overlay.remove();
            
            const container = document.getElementById( 'container' );
            
            
            
            // * * * SCENE SETUP * * *
            
            scene = new THREE.Scene();
            var group = new THREE.Group();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 5000);
            camera.position.set(0,0,100);
            camera.lookAt(scene.position);
            scene.add(camera);
            
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.BasicShadowMap;
            
            
            
            // * * * SKY-SPHERE * * *
            
            const skySphereGeometry = new THREE.SphereGeometry( 4000, 32, 32 );
            const skySphereMaterial = new THREE.MeshPhongMaterial( {
                color: 0xffffff,
                shininess: 100,
                specular: 0x111111,
                side: THREE.BackSide
            } );
            const skySphere = new THREE.Mesh( skySphereGeometry, skySphereMaterial );
            skySphere.receiveShadow = true;
            scene.add( skySphere );
            
            
            
            // * * * MESH * * *
            
            // // TEST: for lighting effects
            // const geometry = new THREE.BoxGeometry( 10, 10, 10 );
            // const material = new THREE.MeshStandardMaterial( { color: 0xffff00 } );
            // const mesh = new THREE.Mesh( geometry, material );
            // scene.add( mesh );
            
            
            var waterGeometry = new THREE.PlaneGeometry(8000, 8000, 500, 500);
            
            SCENE.Destinations['Water'] = new Water(
            waterGeometry,
            {
                textureWidth: 512,
                textureHeight: 512,
                waterNormals: new THREE.TextureLoader().load('textures/waternormals.jpg', function (texture) {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                }),
                alpha: 1.0,
                sunDirection: new THREE.Vector3(),
                sunColor: 0xffffff,
                waterColor: 0x001e0f,
                distortionScale: 3.7,
                fog: scene.fog !== undefined
            }
            );
            
            SCENE.Destinations['Water'].rotation.x = -0.5 * Math.PI;
            SCENE.Destinations['Water'].position.set(0, -100, 0);
            
            group.add( SCENE.Destinations['Water'] );
            
            scene.add( group );
            
            
            
            // * * * LIGHT * * *
            
            function generateTexture() {
                
                const canvas = document.createElement( 'canvas' );
                canvas.width = 2;
                canvas.height = 2;
                
                const context = canvas.getContext( '2d' );
                context.fillStyle = 'white';
                context.fillRect( 0, 1, 2, 1 );
                
                return canvas;
            }
            
            function createLight( color ) {
                
                const intensity = 2000;
                
                const light = new THREE.PointLight( color, intensity, 8000, 0.5 );
                light.castShadow = true;
                light.shadow.bias = - 0.005; // reduces self-shadowing on double-sided objects
                
                const texture = new THREE.CanvasTexture( generateTexture() );
                texture.magFilter = THREE.NearestFilter;
                texture.wrapT = THREE.RepeatWrapping;
                texture.wrapS = THREE.RepeatWrapping;
                texture.repeat.set( 1, 4.5 );
                
                let geometry = new THREE.SphereGeometry( 2, 32, 8 );
                let material = new THREE.MeshPhongMaterial( {
                    side: THREE.DoubleSide,
                    alphaMap: texture,
                    alphaTest: 0.5,
                    opacity: 0
                } );
                
                let sphere = new THREE.Mesh( geometry, material );
                sphere.castShadow = true;
                sphere.receiveShadow = true;
                light.add( sphere );
                
                return light;
            }
            
            
            SCENE.Destinations['Light1'] = createLight( 0x0088ff );
            SCENE.Destinations['Light2'] = createLight( 0xff8888 );
            
            scene.add( SCENE.Destinations['Light1'] );
            scene.add( SCENE.Destinations['Light2'] );
            
            
            
            // * * * WebXR * * *
            
            renderer.xr.enabled = true; // Enable WebXR
            
            // Add VR button
            document.body.appendChild(VRButton.createButton(renderer));
            
            // Create controller
            const controller1 = renderer.xr.getController(0);
            scene.add(controller1);
            
            // Load controller models
            const controllerModelFactory = new XRControllerModelFactory();
            const controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            scene.add(controllerGrip1);
            
            const listener = new THREE.AudioListener();
            
            const audio = new THREE.Audio( listener );
            const file = './sounds/akiko.mp3';
            
            if ( /(iPad|iPhone|iPod)/g.test( navigator.userAgent ) ) {
                
                const loader = new THREE.AudioLoader();
                loader.load( file, function ( buffer ) {
                    
                    audio.setBuffer( buffer );
                    audio.play();
                    
                } );
                
            } else {
                
                const mediaElement = new Audio( file );
                mediaElement.play();
                
                audio.setMediaElementSource( mediaElement );
                
            }
            
            analyser = new THREE.AudioAnalyser( audio, bufferLength );
            
            
            
            // scene.fog = new THREE.FogExp2(0x000000, 0.0003);
            // renderer.setClearColor(scene.fog.color);
            
            
            container.appendChild( renderer.domElement );
            controls = new OrbitControls( camera, renderer.domElement );
            window.addEventListener( 'resize', onWindowResize );
            
            addModulator(5, 1, 0, 75, 50);
            addModulator(1, 2, 0, 30, 50);

            animate();
            
        }
        
        
        function onWindowResize() {
            renderer.setSize( window.innerWidth, window.innerHeight );
        }
        
        
        // * * * EVENT LISTENERS * * *
        
        const startButton = document.getElementById( 'startButton' );
        startButton.addEventListener( 'click', init );
        
        
        function animate() {
            console.log(SCENE.Destinations['Modulator 1→x'])
            
            renderer.setAnimationLoop(function () {
                analyser.getFrequencyData();
                controls.update();    
                
                // Apply all Modulators
                for (let Modulator of SCENE.Modulators) {
                    let destinationParam = SCENE.DestinationParams[Modulator.destinationParam];
                    let destination = SCENE.Destinations[Modulator.destination];
                    let source = SCENE.Sources[Modulator.source]();
                    let x = Modulator.x;
                    let y = Modulator.y;
                    
                    // if the destination is a modulator parameter,
                    // there is no destination param
                    if(typeof destination === 'number') {
                        morphParam(destination, source, x, y);
                    }
                    else {
                        destinationParam(destination, source, x, y);
                    }
                }
                
                // Update the offset of the water texture to create the flowing effect
                SCENE.Destinations['Water'].material.uniforms[ 'time' ].value += 1.0 / 60.0;
                
                
                // Update the position of the Point light
                let time = performance.now() * 0.001;
                
                
                SCENE.Destinations['Light1'].position.x = Math.sin( time * 0.6 ) * 90;
                SCENE.Destinations['Light1'].position.y = Math.sin( time * 0.7 ) * 90 + 6;
                SCENE.Destinations['Light1'].position.z = Math.sin( time * 0.8 ) * 90;
                
                SCENE.Destinations['Light1'].rotation.x = time;
                SCENE.Destinations['Light1'].rotation.z = time;
                
                
                time += 10000;
                
                SCENE.Destinations['Light2'].position.x = Math.sin( time * 0.6 ) * 90;
                SCENE.Destinations['Light2'].position.y = Math.sin( time * 0.7 ) * 90 + 6;
                SCENE.Destinations['Light2'].position.z = Math.sin( time * 0.8 ) * 90;
                
                SCENE.Destinations['Light2'].rotation.x = time;
                SCENE.Destinations['Light2'].rotation.z = time;
                
                renderer.render(scene, camera);
            });
        }
        
        
        
        // * * * HELPER FUNCTIONS * * *
        
        // not actual frequency, just proportional to it
        function getAmplitude(freqLow, freqHigh, data) {
            let total = 0;
            for (let i = freqLow; i < freqHigh; i++) {
                total += data[i];
            }
            return total / (freqHigh - freqLow + 1);
        }
        
        
        
        // * * * MORPHING FUNCTIONS * * *
        
        function morphPosition(object, modData, x, y) {
            switch(object.type) {
                case 'Mesh':
                switch(object.geometry.type) {
                    case 'PlaneGeometry':
                    plane(object, modData, x, y);
                    break;
                    default:
                    console.error("Unsupported geometry type: " + object.geometry.type)
                    break;
                }
                break;
                case 'PointLight':
                light(object, modData, x, y);
                break;
                default:
                console.error("Unsupported object type: " + object.type)
                break;
            }
            
            function plane(object, modData, width, height) {
                
                // Modulate the vertices based on the audio data
                const positions = object.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i++) {
                    const distance = Math.sqrt(
                    Math.pow(positions[i * 3 + 0], 2) +
                    Math.pow(positions[i * 3 + 1], 2)
                    );
                    
                    // if modData is one element, 2d modulation
                    if (modData.length == null) {
                        positions[i * 3 + 2] = object.position.z + (modData * height / 300);
                    }
                    else {
                        const data = modData[Math.floor(distance / (width)) % analyser.data.length] / 256.0;
                        const displacement = data * height;
                        
                        // Update the vertex position based on the original position
                        positions[i * 3 + 2] = object.position.z + displacement;
                    }
                }
                
                // Need to set this flag to true so the changes are picked up by the renderer
                object.geometry.attributes.position.needsUpdate = true;
            }
            
            function light(object, modData, x, y) {
                let data;
                if (modData.length == null) {
                    data = modData;
                }
                else {
                    data = getAmplitude(0, modData.length, modData);
                }
                
                // Update the vertex position based on the original position
                object.intensity = data * x / 100 + y - 100;
            }
        }
        
        function morphSize(object, modData, x, y) {
            const data = modData[0] / 256.0;
            const displacement = data;
            
            // Update the vertex position based on the original position
            object.scale.x = displacement;
            object.scale.y = displacement;
            object.scale.z = displacement;
        }
        
        function morphColor(object, modData, x, y) {
            // const color = object.material.color;
            // const data = modData[0] / 256.0;
            // const displacement = data * x;
            
            // Update the vertex position based on the original position
            object.material.color.set(0xff0000); // This will change the color to red
        }
        
        function morphParam(object, modData, x, y) {
            console.log(object)
            object = modData * (y/100) - 1000 + x;
        }
    </script>
    
</body>
</html>