<!DOCTYPE html>
<html lang="en">
<head>
    <title id="title">three.js webaudio - visualizer</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
    
</head>
<body>
    <div id="overlay">
        <div id="info">
            <a href="https://threejs.org" target="_blank" rel="noopener noreferrer">three.js</a> music - visualizer - vr<br/>
            music by <a href="https://yewtu.be/watch?v=OIFASfPkw9g" target="_blank" rel="noopener">Toshiki Kadomatsu
            </a>
        </div>
        
        <button id="startButton">Play</button>
        <h4>OR</h4>
        <input type="file" id="song-upload" accept="audio/*">
        <h4>OR</h4>
        <button id="micButton">Use Microphone</button>
        
    </div>
    <div id="container"></div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@latest/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@latest/examples/jsm/",
                "three/examples/": "https://unpkg.com/three@latest/examples/jsm/",
                "dat.gui": "https://unpkg.com/dat.gui@latest/build/dat.gui.module.js"
            }
        }
    </script>
    
    <script type="module">
        
        import * as dat from 'dat.gui';
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';      
        import { Water } from 'three/addons/objects/Water.js';
        import { XRControllerModelFactory } from 'three/examples/webxr/XRControllerModelFactory.js';
        import { VRButton } from 'three/examples/webxr/VRButton.js';
        
        
        
        // * * * DAT.GUI * * *
        
        window['SCENE'] = {
            Modulators: [],
            Destinations: {
                'Water': null,
                'Light1': null,
                'Light2': null,
            },
            Sources: {
                'Spectrum Analyzer': () => analyser.data,
                'Bass': () => getAmplitude(0, analyser.data.length / 4, analyser.data),
                'Treble': () => getAmplitude(analyser.data.length / 4, analyser.data.length / 2, analyser.data),
                'Mid': () => getAmplitude(analyser.data.length / 2, analyser.data.length * 3 / 4, analyser.data),
                'High': () => getAmplitude(analyser.data.length * 3 / 4, analyser.data.length, analyser.data),
                'Volume': () => getAmplitude(0, analyser.data.length, analyser.data),
            },
            DestinationParams: {
                'Position': morphPosition,
                // 'Color': morphColor,
                // 'Size': morphSize,
            },
            AddModulator: addModulator
        }
        
        // Define an object to hold the data for dat.GUI
        class modData {
            constructor(source, destination, destinationParam, x, y) {
                SCENE.Modulators.push(this);
                
                this.source = Object.keys(SCENE.Sources)[source];
                this.destination = Object.keys(SCENE.Destinations)[destination];
                this.destinationParam = Object.keys(SCENE.DestinationParams)[destinationParam];
                this.x = x;
                this.y = y;
            }
        }
        
        function addModulator(source=0, destination=0, destinationParam=0, x=50, y=50) {
            let modulator = new modData(source, destination, destinationParam, x, y);
            
            let numModulators = SCENE.Modulators.length;
            
            const newFolder = gui.addFolder('Modulator ' + numModulators);
            
            // Add a dropdown for the sources and destinations to the GUI
            newFolder.add(modulator, 'source', Object.keys(SCENE.Sources));
            newFolder.add(modulator, 'destination', Object.keys(SCENE.Destinations));
            newFolder.add(modulator, 'destinationParam', Object.keys(SCENE.DestinationParams));
            newFolder.add(modulator, 'x').min(1).max(100.0);
            newFolder.add(modulator, 'y').min(1).max(100.0);
            
            // Add the x and y parameters to the destinations object
            SCENE.Destinations['Modulator ' + numModulators + '→x'] = { modulator: modulator, param: "x" };
            SCENE.Destinations['Modulator ' + numModulators + '→y'] = { modulator: modulator, param: "y" };
        }
        
        // Create a new instance of dat.GUI
        const gui = new dat.GUI();
        
        // Add a button to add a modulator
        gui.add(SCENE, 'AddModulator');
        
        
        
        // * * * GLOBALS * * *
        
        var bufferLength = 128;
        
        let songFile = './sounds/akiko.mp3';
        
        let scene, camera, renderer, analyser, controls;
        
        
        
        // * * * MAIN * * *
        
        function init() {
            
            const overlay = document.getElementById( 'overlay' );
            overlay.remove();
            
            const container = document.getElementById( 'container' );
            
            
            
            // * * * SCENE SETUP * * *
            
            scene = new THREE.Scene();
            var group = new THREE.Group();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 5000);
            camera.position.set(0,0,100);
            camera.lookAt(scene.position);
            scene.add(camera);
            
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.BasicShadowMap;
            
            container.appendChild( renderer.domElement );
            
            
            
            // * * * SKY-SPHERE * * *
            
            const skySphereGeometry = new THREE.SphereGeometry( 4000, 32, 32 );
            const skySphereMaterial = new THREE.MeshPhongMaterial( {
                color: 0xffffff,
                shininess: 100,
                specular: 0x111111,
                side: THREE.BackSide
            } );
            const skySphere = new THREE.Mesh( skySphereGeometry, skySphereMaterial );
            skySphere.receiveShadow = true;
            scene.add( skySphere );
            
            
            
            // * * * MESH * * *
            
            // // TEST: for lighting effects
            // const geometry = new THREE.BoxGeometry( 10, 10, 10 );
            // const material = new THREE.MeshStandardMaterial( { color: 0xffff00 } );
            // const mesh = new THREE.Mesh( geometry, material );
            // scene.add( mesh );
            
            
            var waterGeometry = new THREE.PlaneGeometry(8000, 8000, 100, 100);
            var alphaTexture = new THREE.DataTexture(new Uint8Array([64]), 1, 1, THREE.AlphaFormat); // 128 is about 50% opacity
            alphaTexture.needsUpdate = true;

            SCENE.Destinations['Water'] = new Water(
            waterGeometry,
            {
                textureWidth: 512,
                textureHeight: 512,
                waterNormals: new THREE.TextureLoader().load('textures/waternormals.jpg', function (texture) {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                }),
                alphaMap: alphaTexture, // use the alpha texture as the alpha map
                sunDirection: new THREE.Vector3(),
                sunColor: 0x000066,
                waterColor: 0x002244,
                distortionScale: 3.7
            });
            
            SCENE.Destinations['Water'].rotation.x = -0.5 * Math.PI;
            SCENE.Destinations['Water'].position.set(0, -100, 0);
            
            group.add( SCENE.Destinations['Water'] );
            
            scene.add( group );
            
            
            
            // * * * LIGHT * * *
            
            // directional light
            const directionalLight = new THREE.DirectionalLight( 0x2244ff, 1.0 );
            directionalLight.position.set( 0, 1, 0 );
            scene.add( directionalLight );
            
            function createLight( color, width, num, textureFile ) {
                const intensity = 200;
                
                const light = new THREE.PointLight( color, intensity, 8000, 0.5 );
                light.castShadow = true;
                light.shadow.bias = - 0.005; // reduces self-shadowing on double-sided objects
                
                let loader = new THREE.TextureLoader();
                
                loader.load(
                // resource URL
                'textures/' + textureFile,
                
                // onLoad callback
                function ( texture ) {
                    
                    
                    let geometry = new THREE.SphereGeometry( 2, 32, 8 );
                    let material = new THREE.MeshPhongMaterial( {
                        side: THREE.DoubleSide,
                        alphaMap: texture,
                        alphaTest: 0.5,
                        opacity: 0
                    } );
                    let sphere = new THREE.Mesh( geometry, material );
                    sphere.castShadow = true;
                    light.add( sphere );
                },
                
                // onProgress callback currently not supported
                undefined,
                
                // onError callback
                function ( err ) {
                    console.error( 'An error happened.' );
                }
                );
                
                
                
                return light;
            }
            
            
            SCENE.Destinations['Light1'] = createLight( 0x0088ff, 0.5, 36, "blender_wave_texture.png" );
            SCENE.Destinations['Light2'] = createLight( 0xff8888, 0.5, 36, "black.png" );
            
            scene.add( SCENE.Destinations['Light1'] );
            scene.add( SCENE.Destinations['Light2'] );
            
            
            
            // * * * WebXR * * *
            
            renderer.xr.enabled = true; // Enable WebXR
            
            // Add VR button
            document.body.appendChild(VRButton.createButton(renderer));
            
            // Create controller
            const controller1 = renderer.xr.getController(0);
            scene.add(controller1);
            
            // Load controller models
            const controllerModelFactory = new XRControllerModelFactory();
            const controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            scene.add(controllerGrip1);
            
            
            
            // * * * MUSIC * * *
            
            const listener = new THREE.AudioListener();
            const audio = new THREE.Audio( listener );
            
            if (songFile !== null) {
                if ( /(iPad|iPhone|iPod)/g.test( navigator.userAgent ) ) {
                    
                    const loader = new THREE.AudioLoader();
                    loader.load( songFile, function ( buffer ) {
                        
                        audio.setBuffer( buffer );
                        audio.play();
                        
                    } );
                    
                } else {
                    
                    const mediaElement = new Audio( songFile );
                    mediaElement.play();
                    
                    audio.setMediaElementSource( mediaElement );
                    
                }
            }
            else { 
                navigator.mediaDevices.getUserMedia({ audio: true })
                .then(function(stream) {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    audio.setMediaStreamSource( stream );
                })
                .catch(function(err) {
                    console.error('Error accessing microphone: ' + err);
                });
                
                // mute audio to prevent feedback
                listener.setMasterVolume(0);
            }
            
            analyser = new THREE.AudioAnalyser( audio, bufferLength );
            
            
            controls = new OrbitControls( camera, renderer.domElement );
            window.addEventListener( 'resize', onWindowResize );
            
            addModulator();
            addModulator(5, 1, 0, 75, 50);
            addModulator(1, 2, 0, 30, 50);
            addModulator(5, 3, 0, 20, 20);
            addModulator(5, 5, 0, 70, 50);
            
            animate();
        }
        
        
        
        // * * * EVENT LISTENERS * * *        
        
        const startButton = document.getElementById( 'startButton' );
        startButton.addEventListener( 'click', init );
        
        const micButton = document.getElementById( 'micButton' );
        micButton.addEventListener( 'click', function() {
            songFile = null;
            init();
        });
        
        function onWindowResize() {
            renderer.setSize( window.innerWidth, window.innerHeight );
        }
        
        document.getElementById('song-upload').addEventListener('change', function(e) {
            let file = e.target.files[0];
            songFile = URL.createObjectURL(file);
            
            console.log(songFile);
            init();
        });
        
        function animate() {
            
            renderer.setAnimationLoop(function () {
                analyser.getFrequencyData();
                controls.update();    
                
                // Apply all Modulators
                for (let Modulator of SCENE.Modulators) {
                    let destinationParam = SCENE.DestinationParams[Modulator.destinationParam];
                    let destination = SCENE.Destinations[Modulator.destination];
                    let source = SCENE.Sources[Modulator.source]();
                    let x = Modulator.x;
                    let y = Modulator.y;
                    
                    // if the destination is a object with a modulator and param,
                    // there is no destination param
                    if(destination.modulator != null) {
                        morphParam(destination, source, x, y);
                    }
                    else {
                        destinationParam(destination, source, x, y);
                    }
                }
                
                // Update the offset of the water texture to create the flowing effect
                SCENE.Destinations['Water'].material.uniforms[ 'time' ].value += 1.0 / 60.0;
                
                
                function updateLightPositions() {
                    let time = performance.now() * 0.001;

                    for (let i = 1; i <= 100; i++) {
                        let light = SCENE.Destinations['Light' + i];
                        if (typeof light === 'undefined') {
                            break;
                        }

                        light.position.x = Math.sin(time * 0.6) * 90;
                        light.position.y = Math.sin(time * 0.7) * 90 + 6;
                        light.position.z = Math.sin(time * 0.8) * 90;

                        light.rotation.x = time;
                        light.rotation.z = time;

                        time += 10000;
                    }
                }

                // Call the function to update light positions
                updateLightPositions();
                
                renderer.render(scene, camera);
            });
        }
        
        
        
        // * * * HELPER FUNCTIONS * * *
        
        // not actual frequency, just proportional to it
        function getAmplitude(freqLow, freqHigh, data) {
            let total = 0;
            for (let i = freqLow; i < freqHigh; i++) {
                total += data[i];
            }
            return total / (freqHigh - freqLow + 1);
        }
        
        
        
        // * * * MORPHING FUNCTIONS * * *
        
        function morphPosition(object, modData, x, y) {
            switch(object.type) {
                case 'Mesh':
                switch(object.geometry.type) {
                    case 'PlaneGeometry':
                    plane(object, modData, x, y);
                    break;
                    default:
                    console.error("Unsupported geometry type: " + object.geometry.type)
                    break;
                }
                break;
                case 'PointLight':
                light(object, modData, x, y);
                break;
                default:
                console.error("Unsupported object type: " + object.type)
                break;
            }
            
            function plane(object, modData, width, height) {
                
                // Modulate the vertices based on the audio data
                const positions = object.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i++) {
                    const distance = Math.sqrt(
                    Math.pow(positions[i * 3 + 0], 2) +
                    Math.pow(positions[i * 3 + 1], 2)
                    );
                    
                    // if modData is one element, 2d modulation
                    if (modData.length == null) {
                        positions[i * 3 + 2] = object.position.z + (modData * height / 300);
                    }
                    else {
                        const data = modData[Math.floor(distance / (width)) % analyser.data.length] / 256.0;
                        const displacement = data * height;
                        
                        // Update the vertex position based on the original position
                        positions[i * 3 + 2] = object.position.z + displacement;
                    }
                }
                
                // Need to set this flag to true so the changes are picked up by the renderer
                object.geometry.attributes.position.needsUpdate = true;
            }
            
            function light(object, modData, x, y) {
                let data;
                if (modData.length == null) {
                    data = modData;
                }
                else {
                    data = getAmplitude(0, modData.length, modData);
                }
                
                // Update the vertex position based on the original position
                object.intensity = data * x / 100 + y - 100;
            }
        }
        
        function morphSize(object, modData, x, y) {
            const data = modData[0] / 256.0;
            const displacement = data;
            
            // Update the vertex position based on the original position
            object.scale.x = displacement;
            object.scale.y = displacement;
            object.scale.z = displacement;
        }
        
        function morphColor(object, modData, x, y) {
            // const color = object.material.color;
            // const data = modData[0] / 256.0;
            // const displacement = data * x;
            
            // Update the vertex position based on the original position
            object.material.color.set(0xff0000); // This will change the color to red
        }
        
        function morphParam(object, modData, x, y) {
            // if moddata is a list
            if(modData.length != null) {
                modData = getAmplitude(0, modData.length, modData);
            }
            object.modulator[object.param] = modData * (y/200) + (x/100);
        }
    </script>
    
</body>
</html>